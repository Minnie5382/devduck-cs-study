# 14장. 가상 메모리

## 14-1. 연속 메모리 할당
#### 연속적 메모리 할당
> 비어 있는 메모리 공간에 프로세스를 연속적으로 할당하는 방식

 1. 최초 적합
    - OS가 메모리 내의 빈 공간을 순서대로 검색하다가, 적재할 수 있는 공간을 발견하면 거기에 프로세스를 배치
    - 검색 최소화, 빠른 할당 가능
 3. 최적 적합
    - OS가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치
 5. 최악 적합
    - OS가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치

#### 스와핑
> 스와핑 : 현재 실행중이 아닌 프로세스를 임시로 보조기억장치에 쫓아내고, 빈 공간에 다른 프로세스를 적재하는 방식

##### 주요 개념
- 스왑 영역 : 프로세스들이 쫓겨나는 보조기억장치의 영역
- 스왑 아웃 : 메모리에서 스왑 영역으로 쫓겨나는 것
- 스왑 인 : 스왑 영역에서 메모리로 복귀하는 것
<br><br>

##### 특징
- 스와핑을 이용하면 프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 메모리 크기보다 큰 경우에도 프로세스를 동시 실행할 수 있다.
- 연속적 메모리 할당은 외부 단편화라는 문제를 발생시킨다.
  
#### 외부 단편화 (external fragmentation)

![image](https://github.com/Minnie5382/devduck-cs-study/assets/97179789/1c91042b-28fc-4785-b97e-e43a5ff7c20d)

> 외부 단편화 : 프로세스를 할당하기 어려울 정도의 작은 메모리 공간들로 인해 메모리가 낭비되는 현상.

- 외부 단편화의 해결 방안 → 메모리 압축(메모리 조각 모음)
> 메모리 압축 : 흩어져 있는 빈 공간들을 모아서 하나의 큰 빈 공간으로 만드는 기술

- 압축 동안 시스템은 작업을 중지해야 함
- 메모리에 있는 데이터를 옮기는 데 오버 헤드↑
- 압축 방법에 대한 결정 어려움

 ➡️ 페이징 기법!


## 14-2. 페이징을 통한 가상 메모리 관리
#### 페이징이란
> 가상 메모리 : 프로그램의 일부만 메모리에 적재하여, 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술.

> 페이징 : 가상 메모리 기법의 일종. 프로세스의 논리 주소 공간을 페이지 단위로 자르고, 메모리 물리 주소 공간은 프레임 단위로 자른 뒤 각 페이지를 프레임에 할당하는 기법

이게 무슨 말이냐 하면,

가상 메모리 기술을 사용하는 OS에서는, 메모리에 프로세스가 온전히 턱 하고 올라가지 않는다.

왜냐하면, 프로세스를 전부 다 턱 하고 올려버리면 1. 외부 단편화 발생 2. 메모리보다 큰 프로세스는 실행할 수 없기 때문에 프로세스를 잘게 잘라서, 메모리에 흩어지게 배치한다.

이렇게 함으로써 1. 외부 단편화 문제를 해결하고, 2. 페이징 스와핑을 통해 메모리보다 큰 프로세스도 실행할 수 있게 된다.

![image](https://github.com/Minnie5382/devduck-cs-study/assets/97179789/709a326c-2e71-4383-99c0-0639a61bef0d)

> 페이지 : 프로세스를 잘게 자른 단위<br>
> 프레임 : 메모리를 잘게 자른 단위<br>
> 페이지 스와핑 : 페이지 단위로 스와핑 하는 것. 실행에 필요없는 페이지는 페이지 아웃, 실행에 필요한 페이지만 페이지 인 한다.


> 페이지 테이블 : 페이지 번호-프레임 번호의 일대일 대응표

##### 페이지 테이블의 관리
- 페이지 테이블 또한 메모리에 적재되어 있다.
- 페이지 테이블 베이스 레지스터 (PTBR) : 프로세스의 페이지 테이블이 적재된 주소 정보가 있는 레지스터
- TLB(페이지 테이블의 캐시) : 페이지 테이블의 일부 내용을 저장(캐싱)하는 곳. (주로 최근에 사용된 페이지 위주로 저장)
    - TLB 히트 : 접근하려는 논리 주소에 대한 페이지 번호 정보가 TLB에 있는 경우. 바로 프레임 주소를 알 수 있다. 
    - TLB 미스 : 없는 경우. 어쩔 수 없이 메모리에 적재된 페이지 테이블에 접근하여 프레임 주소를 알아내야 한다.
      
#### 내부 단편화

<img width="500" alt="image" src="https://github.com/Minnie5382/devduck-cs-study/assets/97179789/24589e0c-8145-47a7-b5b9-4f88472f2f1d">

> 내부 단편화 : 페이징 기법 사용 중, 프레임 크기가 페이지 하나의 크기보다 커서 메모리가 낭비되는 현상

- 대형 페이지(huge page)<br>
    리눅스 등 일부 OS에서는 설정된 페이지 크기보다 예외적으로 크기가 큰 몇몇 페이지가 있을 수 있다. 크기가 매우 큰 프로세스를 위한 것이다.
  
#### 페이징 주소 변환
페이징 기법에서 특정 메모리에 접근하려면 1. 접근하려는 페이지 번호와 2. 해당 페이지 내에서 몇번째 메모리인지(offset) 두 가지 정보가 필요하다.

![image](https://github.com/Minnie5382/devduck-cs-study/assets/97179789/3af9f7e2-ee2e-4fe3-a772-3a3f89ab5c80)

만약 페이지 크기를 4로 하는 OS라고 가정한다면,
1. <페이지 번호: 3, offset: 2> 주소에 접근할래
2. 페이지 테이블에서 페이지 번호: 3에 해당하는 프레임 번호 검색 → 프레임 번호: 4
3. <프레임 번호: 4, offset: 2>
4. 4*4 + 3 = 19번

이런 과정을 통해, 논리 주소 <페이지 번호, offset> → 물리 주소 <프레임 번호, offset>로 변환된다.

#### 페이지 테이블 엔트리
> 페이지 테이블의 각각의 행

##### 페이지 테이블 엔트리에 포함되는 정보들
1. 유효 비트
   - 페이지가 메모리에 적재되어 있는지 여부. 적재되어 있으면 1, 않으면 0.
   - 페이지 폴트 예외 : 유효 비트가 0인 페이지에 접근하려고 시도할 때 발생하는 예외.
3. 보호 비트
   - 읽기 전용인 페이지인지 여부. 읽기 전용이면 1, 아니면 0.
   - 보호 비트가 1인 페이지에 쓰기를 시도하면 OS가 막아줌.
   - rwx 형식으로도 표현함 ex) 110 : 읽기/쓰기 가능, 실행 불가능.
5. 참조 비트
   - 적재 이후 APU가 읽거나 쓴 페이지인지 여부. 읽거나 썼으면 1, 안 썼으면 0.
7. 수정 비트(더티 비트)
   - 변경된 적이 있는 페이지인지 여부. 변경된 적 있으면 1, 없으면 0.
   - 페이지가 스왑 아웃될 때, 수정 비트가 1이면 변경된 값을 보조기억장치에 기록해야 한다.
     

#### 쓰기 시 복사 (copy on write)


#### 계층적 페이지


# 가상 메모리

## 14-1 연속 메모리 할당

    연속 메모리 할당은 연속적인 메모리 공간을 할당하는 방식입니다.
    ex) 사용자 영역에서 프로세스A는 A의 크기만큼 메모리 주소를 할당받아 연속적으로 배치되고,
        프로세스B는 프로세스A 이후에 또 B의 크기만큼 연속적인 메모리 주소를 할당받아 배치되는 식
    -> 프로세스들이 메모리에 연속적으로 할당할 때 무엇을 고려해야하는지, 어떤 잠재적인 문제가 있는지

### 스와핑

- 메모리에 적재된 프로세스들 중에 현재 실행되지 않는 프로세스를 임시로 **스왑 영역**으로 보내고 남은 메모리상의 빈 공간에 또 다른 프로세스를 적재하여 실행하는 방식

- 스왑아웃 되었던 프로세스가 다시 스왑인될 때는 스왑아웃전에 갖던 물리 주소와는 다른 주소에 적재될 수 있다.
- 스와핑을 이용하면 프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 메모리 크기보다 큰 경우에도 프로세스들을 동시 실행할 수 있다.
  ![스와핑 동시 실행 img] (https://velog.velcdn.com/images/mm723/post/ccef257c-4ca7-4c64-b5d2-8ee010416874/image.png)

#### 용어

- 스왑 영역: 프로세스들이 쫓겨나는 보조기억장치의 일부 영역
- 스왑 아웃: 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것
- 스왑 인: 스왑 영역에 있던 프로세스가 다시 메모리로 옮겨오는 것

### 메모리 할당(비어 있는 메모리 공간에 프로세스를 연속적으로 할당하는 방식)

- 상황: 20MB 크기의 프로세스를 적재하고 싶을 때
  ![예시 상황 img] (https://velog.velcdn.com/images/thdgusrbek/post/598b7805-1b8b-42c8-9ab5-1f4889ca4828/image.png)

- 최초적합: 운영체제가 메모리 내의 빈 공간을 **순서대로 검색하다가** 적재할 수 있는 공간을 **발견하면** 그 공간에 프로세스를 배치하는 방식

  - 빈 공간 A에 배치
  - 검색을 최소화, 빠른 할당

- 최적적합: 빈 공간을 **모두 검색해 본 후**, 프로세스가 **적재될 수 있는 공간 중 가장 작은 공간**에 프로세스를 배치하는 방식

  - 빈 공간 C에 배치

- 최악접합: 빈 공간을 **모두 검색해 본 후**, 프로세스가 **적재될 수 있는 공간 중 가장 큰 공간**에 프로세스를 배치하는 방식
  - 빈 공간 B에 배치

### 외부 단편화

    연속 메모리 할당은 외부 단편화라는 문제를 내포하고 있기 때문에 메모리를 효율적으로 사용하는 방법이 아닙니다.

- 프로세스들이 메모리에 연속적으로 할당되는 환경에서는 프로세스들이 실행되고 종료되기를 반복하며 메모리 사이 사이에 빈 공간들이 생긴다. 빈 공간이지만 그 공간보다 큰 프로세스를 적재하기 어려운 상황을 초래하고, 결국 메모리 낭비로 이어진다. 이러한 현상을 **외부 단편화**(external fragmentation)

- 해결 빙법
  - 압축: 흩어져 있는 빈 공간들을 하나로 모으는 방식
    - 단점
      - 모으는 동안 시스템은 하던 일을 중지
      - 메모리에 있는 내용을 옮기는 작업은 많은 오버헤드를 야기
  - 페이징 기법

<hr/>

## 14-2 페이징을 통한 가상 메모리 관리

- 연속 메모리 할당 방식의 문제점
  - 외부 단편화, 물리 메모리보다 큰 프로세스를 실행할 수 없다
    - 해결: 가상메모리로 실행하고자 하는 프로그램을 일부만 메로리에 적재하여 실제 물리 메모리크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술.
      - 가상 메모리의 기법
        - 페이징
        - 세그멘테이션

### 페이징이란

- 메모리의 물리 주소 공간을 **프레임** 단위로 자르고, 프로세스의 논리 주소 공간을 **페이지** 단위로 자른 뒤 각 페이지를 프레임에 할당하는 가상 메모리 관리 기법
- 페이징에서 스와핑: 페이지 단위로 페이지 아웃/페이지 인
  프로세스를 이루는 페이지 중 실행에 필요한 일부 페이지만을 메모리에 적재하고, 당장 실행에 필요하지 않은 페이지들은 보조기억장치에 남겨둘 수 있다.

### 페이지 테이블

    프로세스가 메모리에 불연속적으로 배치되어 있다면 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지
    CPU가 알기 어렵기 때문에 순차적으로 실행할 수 없습니다.

- 페이징 시스템은 프로세스가 물리주소에 불연속으로 배치되더라도 논리주소에는 연속적으로 배치되도록 페이지 테이블을 이용한다.
- 페이지테이블은 페이지 번호와 프레임 번호를 짝지어준다.
- 프로세스마다 각자의 **프로세스 테이블**을 가지고 있고, 각 프로세스의 페이지 테이블들은 **메모리에 적재**되어 있다.\
- CPU내의 **페이지 테이블 베이스 레지스터**(PTBR)는 각 프로세스의 페이지 테이블이 적재된 주소를 가리킨다.
- 페이지 테이블을 메모리에 두면 메모리 접근시간이 두 배로 늘어나는 문제가 생긴다.
  - 해결 방법
    - CPU 곁에 TLB라는 페이지 테이블의 캐시메모리(참조지역성에 근거해 주로 최근에 사용도니 페이지 위조로 가져와 저장)를 둔다.
    - CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있을 경우 이를 **TLB히트**라고 한다.
      - 이 경우 페이지가 적재된 프레임을 알기 위해 메모리에 접근할 필요 없다.
    - TLB에 페이지 번호가 없을 경우 메모리 내의 페이지 테이블에 접근한다. 이를 **TLB미스**라고 한다.

### 페이징에서의 주소 변환

- 페이지 번호와 변위: CPU가 생성하는 논리적 주소는 페이지 번호(page number)와 변위(offset)으로 구성됩니다.

  - 페이지 번호: 접근하고자 하는 페이지 번호
    - 페이지 테이블에서 해당 페이지 번호를 찾으면 페이지가 어떤 프레임에 할당되었는지를 알 수 있다.
  - 변위: 접근하려는 주소가 프레임의 시작 번지로부터 얼마큼 떨어져 있는지를 알기 위한 정보
    - 논리 주소 <페이지 번호, 변위>는 페이지 테이블을 통해 물리주소 <프레임 번호, 변위>로 변환된다.

- 페이지 테이블: 논리 주소의 페이지 번호는 페이지 테이블을 통해 해당하는 프레임 번호로 변환됩니다.

### 페이지 테이블 엔트리

    페이지 테이블의 각각의 행들을 페이지 엔트리라고 한다.
    페이지 엔트리에 담기는 정보는 페이지번호, 프레임번호 말고도 유효 비트, 보호 비트, 참조 비트, 수정 비트 등이 있다.

- 유효 비트

  - 기능: 유효 비트는 페이지가 물리 메모리에 존재하는지를 나타냅니다.
  - 상태
    - 1: 해당 페이지가 물리 메모리에 로드(적재)되어 있음을 나타내고, 접근이 가능하다는 것을 의미한다.
    - 0: 페이지가 물리 메모리에 없음을 나타내며, 접근하려고 하면 **페이지 폴트(page fault)**가 발생한다.
  - 페이지 폴트를 처리하는 과정(하드웨어 인터럽트를 처리하는 과정과 유사)
    - 1.CPU는 기존의 작업 내역을 백업한다.
    - 2.페이지 폴트 처리 루틴을 실행한다.
    - 3.페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 유효 비트를 1로 변경해준다.
    - 4.처리하면 이제 CPU는 해당 페이지에 접근할 수 있다.

- 보호 비트

  - 기능: 보호 비트는 페이지에 대한 접근 권한(읽기, 쓰기, 실행)을 제어한다.
  - 상태
    - 1: 쓰기 기능을 의미하고, 내용을 변경할 수 있다
    - 0: 읽기 전용 모드이고, 내용을 변경할 수 없다.
  - 세 개의 비트로 구현

    - R (Read)

      - 0: 읽기 금지 - 프로세스는 페이지 내용을 읽을 수 없다.
      - 1: 읽기 허용 - 프로세스가 페이지의 데이터를 읽을 수 있다.

    - W (Write)

      - 0: 쓰기 금지 - 프로세스는 페이지 내용을 변경할 수 없다.
      - 1: 쓰기 허용 - 프로세스가 페이지에 데이터를 쓸 수 있다.

    - X (Execute)

      - 0: 실행 금지 - 프로세스는 페이지 내용을 실행할 수 없다.
      - 1: 실행 허용 - 페이지를 실행 코드로 사용할 수 있다.

- 참조 비트

  - 기능: 참조 비트는 해당 페이지가 최근에 참조(접근)되었는지를 나타낸다. 이 비트는 페이지 교체 알고리즘에서 중요한 역할을 한다.
  - 상태
    - 1: 페이지가 최근에 참조(접근)되었음을 나타낸다.
    - 0: 페이지가 최근에 참조되지 않았음을 나타낸다.

- 수정 비트

  - 기능: 수정 비트는 해당 페이지가 수정(쓰기 작업)되었는지를 나타낸다.
  - 상태
    - 1: 페이지가 수정되었음을 나타냅니다. 페이지가 메모리에서 변경된 후 디스크에 아직 반영되지 않았다는 것을 의미한다.
    - 0: 페이지가 수정되지 않았음을 나타냅니다. 페이지에 쓰기 작업이 수행되지 않았거나, 수정된 내용이 디스크에 이미 저장되어 메모리와 디스크의 내용이 일치함을 의미한다.

  <hr/>

## 14-3 페이지 교체와 프레임 할당

### 요구 페이징

### 페이지 교체 알고리즘

### 스래싱과 프레임 할당
